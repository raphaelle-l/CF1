import React, { useState, useEffect, useRef } from 'react';
import { Play, RotateCcw } from 'lucide-react';

const EndlessRunner = () => {
  const canvasRef = useRef(null);
  const [gameState, setGameState] = useState('menu'); // menu, playing, gameOver
  const [score, setScore] = useState(0);
  const [highScore, setHighScore] = useState(0);
  
  const gameRef = useRef({
    player: { x: 100, y: 300, vy: 0, width: 30, height: 30, isJumping: false, jumpsLeft: 2, inPortal: false, targetPortal: null },
    obstacles: [],
    particles: [],
    platforms: [],
    portals: [],
    speed: 5,
    baseSpeed: 5,
    gravity: 0.6,
    jumpPower: -12,
    groundY: 400,
    score: 0,
    frameCount: 0,
    lastObstacleFrame: 0,
    lastPlatformFrame: 0,
    lastPortalFrame: 0,
    lastObstacleWaveFrame: 0
  });

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    let animationId;

    const createParticles = (x, y, count, color) => {
      const particles = [];
      for (let i = 0; i < count; i++) {
        particles.push({
          x,
          y,
          vx: (Math.random() - 0.5) * 6,
          vy: (Math.random() - 0.5) * 6,
          life: 1,
          decay: 0.02 + Math.random() * 0.02,
          size: 2 + Math.random() * 3,
          color
        });
      }
      return particles;
    };

    const createObstacle = () => {
      const types = ['box', 'tall', 'wide'];
      const type = types[Math.floor(Math.random() * types.length)];
      let width, height;
      
      if (type === 'box') {
        width = 30 + Math.random() * 20;
        height = 30 + Math.random() * 20;
      } else if (type === 'tall') {
        width = 20;
        height = 50 + Math.random() * 30;
      } else {
        width = 50 + Math.random() * 30;
        height = 20;
      }
      
      return {
        x: canvas.width,
        y: gameRef.current.groundY - height,
        width,
        height,
        type
      };
    };

    const createPlatform = () => {
      const game = gameRef.current;
      const difficulty = Math.floor(game.score / 200); // Difficulty increases every 200 score
      
      // Chance for stacked platforms at higher difficulty
      if (difficulty >= 2 && Math.random() < 0.3) {
        const bottom = {
          x: canvas.width,
          y: 280 + Math.random() * 80,
          width: 80 + Math.random() * 40,
          height: 15,
          isStacked: true
        };
        const top = {
          x: canvas.width + 40 + Math.random() * 40,
          y: bottom.y - 80 - Math.random() * 30,
          width: 80 + Math.random() * 40,
          height: 15,
          isStacked: true
        };
        return [bottom, top];
      }
      
      return [{
        x: canvas.width,
        y: 200 + Math.random() * 150,
        width: 80 + Math.random() * 60,
        height: 15,
        isStacked: false
      }];
    };

    const createPlatformObstacle = (platformX, platformY, platformWidth) => {
      return {
        x: platformX + 20 + Math.random() * (platformWidth - 40),
        y: platformY - 30,
        width: 25,
        height: 30,
        type: 'platform'
      };
    };

    const createPortalPair = () => {
      const entrance = {
        x: canvas.width,
        y: 150 + Math.random() * 200,
        width: 40,
        height: 60,
        type: 'entrance',
        color: '#2F5755',
        glowColor: '#54C6BE'
      };
      
      // Exit spawns further ahead with safe positioning
      const exit = {
        x: canvas.width + 400 + Math.random() * 300,
        y: 150 + Math.random() * 200,
        width: 40,
        height: 60,
        type: 'exit',
        color: '#2F5755',
        glowColor: '#F7B15C',
        entrance: entrance,
        hasSafeZone: true // Mark that this exit needs obstacle clearance
      };
      
      entrance.exit = exit;
      
      return [entrance, exit];
    };

    const resetGame = () => {
      const game = gameRef.current;
      game.player = { x: 100, y: 300, vy: 0, width: 30, height: 30, isJumping: false, jumpsLeft: 2, inPortal: false, targetPortal: null };
      game.obstacles = [];
      game.platforms = [];
      game.portals = [];
      game.particles = [];
      game.speed = game.baseSpeed;
      game.score = 0;
      game.frameCount = 0;
      game.lastObstacleFrame = 0;
      game.lastPlatformFrame = 0;
      game.lastPortalFrame = 0;
      game.lastObstacleWaveFrame = 0;
    };

    const checkCollision = (rect1, rect2) => {
      return rect1.x < rect2.x + rect2.width &&
             rect1.x + rect1.width > rect2.x &&
             rect1.y < rect2.y + rect2.height &&
             rect1.y + rect1.height > rect2.y;
    };

    const gameLoop = () => {
      const game = gameRef.current;
      const player = game.player;
      
      ctx.fillStyle = '#000000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw stars background
      ctx.fillStyle = '#54C6BE';
      for (let i = 0; i < 50; i++) {
        const x = (i * 123.456) % canvas.width;
        const y = (i * 78.901) % canvas.height;
        const size = (i % 3) * 0.5 + 0.5;
        ctx.fillRect(x, y, size, size);
      }

      // Draw ground with gradient
      const groundGradient = ctx.createLinearGradient(0, game.groundY, 0, canvas.height);
      groundGradient.addColorStop(0, '#2F5755');
      groundGradient.addColorStop(1, '#1a3332');
      ctx.fillStyle = groundGradient;
      ctx.fillRect(0, game.groundY, canvas.width, canvas.height - game.groundY);

      // Ground line
      ctx.strokeStyle = '#54C6BE';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, game.groundY);
      ctx.lineTo(canvas.width, game.groundY);
      ctx.stroke();

      // Update and draw particles
      game.particles = game.particles.filter(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.life -= p.decay;
        
        if (p.life > 0) {
          ctx.globalAlpha = p.life;
          ctx.fillStyle = p.color;
          ctx.fillRect(p.x, p.y, p.size, p.size);
          ctx.globalAlpha = 1;
          return true;
        }
        return false;
      });

      // Check if player should emerge from portal
      if (player.inPortal && player.targetPortal) {
        if (player.targetPortal.x <= player.x) {
          // Portal has reached player's x position, emerge!
          player.y = player.targetPortal.y + player.targetPortal.height / 2 - player.height / 2;
          player.inPortal = false;
          
          // Massive particle explosion
          game.particles.push(...createParticles(
            player.x + player.width / 2,
            player.y + player.height / 2,
            30,
            player.targetPortal.color
          ));
          
          // Mark exit portal for safe zone
          player.targetPortal.justExited = true;
          player.targetPortal.safeZoneEnd = player.targetPortal.x + 1000; // Safe zone extends 1000px ahead
          
          player.targetPortal = null;
        }
      }

      // Player physics (only if not in portal)
      if (!player.inPortal) {
        player.vy += game.gravity;
        player.y += player.vy;
      }

      // Check ground collision
      if (!player.inPortal && player.y + player.height >= game.groundY) {
        player.y = game.groundY - player.height;
        player.vy = 0;
        player.isJumping = false;
        player.jumpsLeft = 2;
        
        // Landing particles
        if (Math.abs(player.vy) > 2) {
          game.particles.push(...createParticles(
            player.x + player.width / 2,
            player.y + player.height,
            5,
                          '#54C6BE'
          ));
        }
      }

      // Check platform collision
      if (!player.inPortal) {
        game.platforms.forEach(platform => {
          if (platform && player.vy > 0 &&
              player.y + player.height <= platform.y + 10 &&
              player.y + player.height + player.vy >= platform.y &&
              player.x + player.width > platform.x &&
              player.x < platform.x + platform.width) {
            player.y = platform.y - player.height;
            player.vy = 0;
            player.isJumping = false;
            player.jumpsLeft = 2;
          }
        });
      }

      // Draw player with glow (only if not in portal)
      if (!player.inPortal) {
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#54C6BE';
        ctx.fillStyle = '#54C6BE';
        ctx.fillRect(player.x, player.y, player.width, player.height);
        
        // Player eye
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#000000';
        ctx.fillRect(player.x + 20, player.y + 10, 6, 6);
        
        // Trail particles
        if (game.frameCount % 3 === 0) {
          game.particles.push(...createParticles(
            player.x,
            player.y + player.height / 2,
            2,
            '#54C6BE'
          ));
        }
      }

      // Spawn obstacles
      const difficulty = Math.floor(game.score / 200);
      
      // Long obstacle waves at high difficulty
      if (difficulty >= 3 && game.frameCount - game.lastObstacleWaveFrame > 800) {
        // Check if there are any portal exit safe zones
        let canSpawnWave = true;
        game.portals.forEach(portal => {
          if (portal.type === 'exit' && portal.hasSafeZone) {
            const waveEnd = canvas.width + 640; // Wave covers ~640px
            if (portal.x < waveEnd && portal.x + 1000 > canvas.width) {
              canSpawnWave = false;
            }
          }
        });
        
        if (canSpawnWave) {
          // Create a wave of obstacles forcing platform use
          const waveStart = canvas.width;
          for (let i = 0; i < 8; i++) {
            game.obstacles.push({
              x: waveStart + i * 80,
              y: game.groundY - 35,
              width: 60,
              height: 35,
              type: 'wave'
            });
          }
          
          // Spawn platforms above the wave to ensure it's passable
          const platformCount = 3;
          for (let i = 0; i < platformCount; i++) {
            game.platforms.push({
              x: waveStart + 100 + i * 180,
              y: 250 + (i % 2) * 50,
              width: 100,
              height: 15,
              isWavePlatform: true
            });
          }
          
          game.lastObstacleWaveFrame = game.frameCount;
          game.lastObstacleFrame = game.frameCount + 200; // Delay next normal obstacle
        }
      } else if (game.frameCount - game.lastObstacleFrame > 90 - Math.min(game.score / 100, 40)) {
        // Check if there's a safe zone active (from recent portal exit or upcoming portal)
        let canSpawn = true;
        const spawnX = canvas.width;
        
        game.portals.forEach(portal => {
          // Check active safe zones (already exited)
          if (portal.type === 'exit' && portal.justExited && portal.safeZoneEnd) {
            if (spawnX < portal.safeZoneEnd) {
              canSpawn = false;
            }
          }
          // Check upcoming exit portals
          if (portal.type === 'exit' && portal.hasSafeZone && portal.x > 0) {
            // Don't spawn obstacles in the zone around the exit portal
            const safeStart = portal.x - 200;
            const safeEnd = portal.x + portal.width + 1000;
            if (spawnX >= safeStart && spawnX <= safeEnd) {
              canSpawn = false;
            }
          }
        });
        
        if (canSpawn) {
          game.obstacles.push(createObstacle());
          game.lastObstacleFrame = game.frameCount;
        }
      }

      // Spawn platforms
      if (game.frameCount - game.lastPlatformFrame > 150) {
        try {
          const newPlatforms = createPlatform();
          game.platforms.push(...newPlatforms);
          
          // Add obstacles on platforms at higher difficulty
          const difficulty = Math.floor(game.score / 200);
          if (difficulty >= 1 && Math.random() < 0.4) {
            newPlatforms.forEach(plat => {
              if (plat && plat.width > 50 && Math.random() < 0.5) {
                game.obstacles.push(createPlatformObstacle(plat.x, plat.y, plat.width));
              }
            });
          }
          
          game.lastPlatformFrame = game.frameCount;
        } catch (e) {
          console.error('Platform spawn error:', e);
          game.lastPlatformFrame = game.frameCount;
        }
      }

      // Spawn portals
      if (game.frameCount - game.lastPortalFrame > 300 && Math.random() < 0.5) {
        const [entrance, exit] = createPortalPair();
        game.portals.push(entrance, exit);
        game.lastPortalFrame = game.frameCount;
      }

      // Update and draw obstacles
      game.obstacles = game.obstacles.filter(obs => {
        if (!obs) return false;
        obs.x -= game.speed;
        
        if (obs.x + obs.width > 0) {
          // Draw obstacle with glow
          ctx.shadowBlur = 10;
          ctx.shadowColor = '#E5243F';
          ctx.fillStyle = '#E5243F';
          ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
          ctx.shadowBlur = 0;
          
          // Obstacle detail
          ctx.fillStyle = '#F65C51';
          ctx.fillRect(obs.x + 5, obs.y + 5, obs.width - 10, obs.height - 10);
          
          // Check collision (only if player is not in portal)
          if (!player.inPortal && checkCollision(player, obs)) {
            game.particles.push(...createParticles(
              player.x + player.width / 2,
              player.y + player.height / 2,
              20,
              '#E5243F'
            ));
            setGameState('gameOver');
            if (game.score > highScore) {
              setHighScore(game.score);
            }
          }
          
          return true;
        }
        return false;
      });

      // Update and draw platforms
      game.platforms = game.platforms.filter(plat => {
        if (!plat) return false;
        plat.x -= game.speed;
        
        if (plat.x + plat.width > 0) {
          ctx.shadowBlur = 8;
          ctx.shadowColor = '#F7B15C';
          ctx.fillStyle = '#F7B15C';
          ctx.fillRect(plat.x, plat.y, plat.width, plat.height);
          ctx.shadowBlur = 0;
          
          ctx.fillStyle = '#e09a48';
          ctx.fillRect(plat.x + 5, plat.y + 3, plat.width - 10, plat.height - 6);
          
          return true;
        }
        return false;
      });

      // Update and draw portals
      game.portals = game.portals.filter(portal => {
        portal.x -= game.speed;
        
        // Update safe zone
        if (portal.safeZoneEnd) {
          portal.safeZoneEnd -= game.speed;
          if (portal.safeZoneEnd < 0) {
            portal.justExited = false;
            portal.safeZoneEnd = null;
          }
        }
        
        if (portal.x + portal.width > 0) {
          // Portal animation
          const time = game.frameCount * 0.1;
          
          // Draw portal oval with pulsing effect
          ctx.save();
          ctx.translate(portal.x + portal.width / 2, portal.y + portal.height / 2);
          
          // Outer glow
          ctx.shadowBlur = 20 + Math.sin(time) * 5;
          ctx.shadowColor = portal.glowColor;
          
          // Portal ring
          ctx.strokeStyle = portal.color;
          ctx.lineWidth = 6;
          ctx.beginPath();
          ctx.ellipse(0, 0, portal.width / 2, portal.height / 2, 0, 0, Math.PI * 2);
          ctx.stroke();
          
          // Inner swirl
          ctx.shadowBlur = 15;
          ctx.strokeStyle = portal.glowColor;
          ctx.lineWidth = 3;
          for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.ellipse(0, 0, (portal.width / 2 - 10) * (0.3 + i * 0.3), 
                       (portal.height / 2 - 10) * (0.3 + i * 0.3), 
                       time + i, 0, Math.PI * 2);
            ctx.stroke();
          }
          
          ctx.restore();
          
          // Portal particles
          if (game.frameCount % 5 === 0) {
            game.particles.push(...createParticles(
              portal.x + portal.width / 2,
              portal.y + portal.height / 2,
              2,
              portal.color
            ));
          }
          
          // Check collision with player
          const dx = (player.x + player.width / 2) - (portal.x + portal.width / 2);
          const dy = (player.y + player.height / 2) - (portal.y + portal.height / 2);
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < 30 && portal.type === 'entrance' && portal.exit && !player.inPortal) {
            // Player enters portal - hide them and store target
            player.inPortal = true;
            player.targetPortal = portal.exit;
            player.vy = 0; // Stop vertical movement while in portal
            
            // Particle explosion at entrance
            game.particles.push(...createParticles(
              portal.x + portal.width / 2,
              portal.y + portal.height / 2,
              30,
              portal.color
            ));
          }
          
          return true;
        }
        return false;
      });

      // Increase speed over time
      game.speed = game.baseSpeed + game.score / 500;

      // Update score
      game.score++;
      game.frameCount++;
      
      if (game.frameCount % 10 === 0) {
        setScore(Math.floor(game.score / 10));
      }

      // Score display
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 24px sans-serif';
      ctx.fillText(`Score: ${Math.floor(game.score / 10)}`, 20, 40);
      ctx.font = '16px sans-serif';
      ctx.fillText(`Speed: ${game.speed.toFixed(1)}x`, 20, 70);

      animationId = requestAnimationFrame(gameLoop);
    };

    const handleKeyDown = (e) => {
      if (e.code === 'Space') {
        if (gameState === 'menu' || gameState === 'gameOver') {
          e.preventDefault();
          startGame();
          return;
        }
        
        if (gameState === 'playing' && gameRef.current.player.jumpsLeft > 0) {
          e.preventDefault();
          gameRef.current.player.vy = gameRef.current.jumpPower;
          gameRef.current.player.isJumping = true;
          gameRef.current.player.jumpsLeft--;
          
          // Jump particles with color based on jump type
          const particleColor = gameRef.current.player.jumpsLeft === 1 ? '#54C6BE' : '#F7B15C';
          game.particles.push(...createParticles(
            gameRef.current.player.x + gameRef.current.player.width / 2,
            gameRef.current.player.y + gameRef.current.player.height,
            gameRef.current.player.jumpsLeft === 1 ? 8 : 12,
            particleColor
          ));
        }
      }
    };

    window.addEventListener('keydown', handleKeyDown);

    if (gameState === 'playing') {
      gameLoop();
    }

    return () => {
      cancelAnimationFrame(animationId);
      window.removeEventListener('keydown', handleKeyDown);
    };
  }, [gameState, highScore]);

  const startGame = () => {
    gameRef.current.player = { x: 100, y: 300, vy: 0, width: 30, height: 30, isJumping: false, jumpsLeft: 2, inPortal: false, targetPortal: null };
    gameRef.current.obstacles = [];
    gameRef.current.platforms = [];
    gameRef.current.portals = [];
    gameRef.current.particles = [];
    gameRef.current.speed = gameRef.current.baseSpeed;
    gameRef.current.score = 0;
    gameRef.current.frameCount = 0;
    gameRef.current.lastObstacleFrame = 0;
    gameRef.current.lastPlatformFrame = 0;
    gameRef.current.lastPortalFrame = 0;
    gameRef.current.lastObstacleWaveFrame = 0;
    setScore(0);
    setGameState('playing');
  };

  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-black p-4">
      <div className="relative">
        <canvas
          ref={canvasRef}
          width={800}
          height={450}
          className="border-4 border-gray-800 rounded-lg shadow-2xl"
        />
        
        {gameState === 'menu' && (
          <div className="absolute inset-0 flex flex-col items-center justify-center bg-black/90 rounded-lg">
            <h1 className="text-6xl font-bold mb-4" style={{color: '#54C6BE'}}>RUNNER</h1>
            <p className="text-xl mb-8" style={{color: '#F7B15C'}}>Press SPACE to jump</p>
            <button
              onClick={startGame}
              className="flex items-center gap-2 text-white px-8 py-4 rounded-lg text-xl font-bold transition-colors"
              style={{backgroundColor: '#E5243F'}}
              onMouseEnter={(e) => e.target.style.backgroundColor = '#F65C51'}
              onMouseLeave={(e) => e.target.style.backgroundColor = '#E5243F'}
            >
              <Play size={24} />
              Start Game
            </button>
            {highScore > 0 && (
              <p className="text-gray-400 mt-4">High Score: {highScore}</p>
            )}
          </div>
        )}
        
        {gameState === 'gameOver' && (
          <div className="absolute inset-0 flex flex-col items-center justify-center bg-black/90 rounded-lg">
            <h2 className="text-5xl font-bold mb-4" style={{color: '#E5243F'}}>Game Over</h2>
            <p className="text-2xl mb-2" style={{color: '#F7B15C'}}>Score: {score}</p>
            {score === highScore && score > 0 && (
              <p className="text-xl mb-4" style={{color: '#F7B15C'}}>New High Score! üèÜ</p>
            )}
            <button
              onClick={startGame}
              className="flex items-center gap-2 text-white px-8 py-4 rounded-lg text-xl font-bold transition-colors"
              style={{backgroundColor: '#E5243F'}}
              onMouseEnter={(e) => e.target.style.backgroundColor = '#F65C51'}
              onMouseLeave={(e) => e.target.style.backgroundColor = '#E5243F'}
            >
              <RotateCcw size={24} />
              Play Again
            </button>
          </div>
        )}
      </div>
      
      <div className="mt-6 text-center text-gray-400">
        <p className="text-sm">Press SPACE to jump (double jump available!) ‚Ä¢ Avoid red obstacles ‚Ä¢ Use orange platforms</p>
        <p className="text-xs mt-2" style={{color: '#54C6BE'}}>Dark teal portals with cyan/orange glow teleport you ‚Ä¢ Speed increases as you progress!</p>
      </div>
    </div>
  );
};

export default EndlessRunner;